#include "gt1151.h"
#include "touch.h"
#include "ctiic.h"
#include "usart.h"
#include "delay.h" 
#include "string.h" 


//GT1151配置参数表
//第一个字节为版本号(0X60),必须保证新的版本号大于等于GT1151内部
//flash原有版本号,才会更新配置.
//#define dev55 1
const u8 GT1151_CFG_TBL[]=
{
#ifdef	dev55
0xFF,0xD0,0x02,0x00,0x05,0x0A,0x0D,0x00,0x01,0x40,
0x00,0x0B,0x78,0x64,0x53,0x04,0x00,0x00,0x00,0x00,
0x28,0x00,0x00,0x00,0x08,0x04,0x00,0x02,0x28,0x78,
0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x9B,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x89,0x28,0x1E,0x4E,
0x50,0x85,0x0C,0x38,0x6D,0x38,0xDD,0x03,0x26,0x00,
0x05,0x5A,0x87,0x00,0x4F,0x55,0x32,0x01,0x04,0x68,
0x61,0x6E,0x68,0x75,0x70,0x75,0x77,0x8B,0x7F,0x9C,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x23,0x23,0x81,0x00,0x0F,0x0F,0x04,
0x0E,0x88,0x88,0x88,0x08,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x37,
0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,
0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x12,0x13,0x14,0x15,
0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
0xFF,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x12,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x13,0x1E,0x6D,0x01,0x00,0x00,0x00,0x0A,
0x00,0x00,0x00,0xD0,0x07,0x50,0x39,0x8E,0x01
#else
0xFF,0x38,0x04,0x80,0x07,0x0A,0x0D,0x00,0x01,0x40,
0x00,0x0B,0x78,0x64,0x53,0x04,0x00,0x00,0x00,0x00,
0x28,0x00,0x00,0x00,0x08,0x04,0x00,0x02,0x28,0x78,
0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x9B,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x28,0x1C,0x4E,
0x50,0x85,0x0C,0x38,0x6D,0x38,0xDD,0x03,0x26,0x00,
0x05,0x5A,0x87,0x00,0x4F,0x55,0x32,0x01,0x04,0x68,
0x61,0x6E,0x68,0x75,0x70,0x75,0x77,0x8B,0x7F,0x9C,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x23,0x23,0x00,0x00,0x0F,0x0F,0x04,
0x0E,0x88,0x88,0x88,0x08,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x37,
0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,
0x0D,0x0E,0x0F,0x10,0x12,0x13,0x14,0x15,0x16,0x17,
0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0xFF,0xFF,
0xFF,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0xFF,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x13,0x1E,0x6D,0x01,0x00,0x00,0x00,0x0A,
0x00,0x00,0x00,0xD0,0x07,0x50,0x4D,0x2A,0x01
#endif
}; 
u8 buf0[sizeof(GT1151_CFG_TBL)]={0};
//发送GT1151配置参数
//mode:0,参数不保存到flash
//     1,参数保存到flash
u8 GT1151_Send_Cfg(u8 mode)
{
	u8 buf[3];
	u8 i=0;
	u8 ret = 0;
	u16 sum=0;
	buf[0]=0;
	buf[1]=0;
	buf[2]=mode;	//是否写入到GT1151 FLASH?  即是否掉电保存
	//for(i=0;i<sizeof(GT1151_CFG_TBL);i++)sum+=GT1151_CFG_TBL[i];//计算校验和

	buf[0]=(sum>>8);
	buf[1]=sum&0xff;
	ret = GT1151_WR_Reg(GT_CFGS_REG,(u8*)GT1151_CFG_TBL,sizeof(GT1151_CFG_TBL));//发送寄存器配置
	//GT1151_WR_Reg(GT_CHECK_REG,buf,3);//写入校验和,和配置更新标记
	return 0;
}  
//向GT1151写入一次数据
//reg:起始寄存器地址
//buf:数据缓缓存区
//len:写数据长度
//返回值:0,成功;1,失败.
u8 GT1151_WR_Reg(u16 reg,u8 *buf,u8 len)
{
	u8 i;
	u8 ret=0;
	CT_IIC_Start();	
 	CT_IIC_Send_Byte(GT_CMD_WR);   	//发送写命令 	 
	CT_IIC_Wait_Ack();
	CT_IIC_Send_Byte(reg>>8);   	//发送高8位地址
	CT_IIC_Wait_Ack(); 	 										  		   
	CT_IIC_Send_Byte(reg&0XFF);   	//发送低8位地址
	CT_IIC_Wait_Ack();  
	for(i=0;i<len;i++)
	{	   
    	CT_IIC_Send_Byte(buf[i]);  	//发数据
		ret=CT_IIC_Wait_Ack();
		if(ret)break;  
	}
    CT_IIC_Stop();					//产生一个停止条件	    
	return ret; 
}
//从GT1151读出一次数据
//reg:起始寄存器地址
//buf:数据缓缓存区
//len:读数据长度			  
void GT1151_RD_Reg(u16 reg,u8 *buf,u8 len)
{
	u8 i; 
 	CT_IIC_Start();	
 	CT_IIC_Send_Byte(GT_CMD_WR);   //发送写命令 	 
	CT_IIC_Wait_Ack();
 	CT_IIC_Send_Byte(reg>>8);   	//发送高8位地址
	CT_IIC_Wait_Ack(); 	 										  		   
 	CT_IIC_Send_Byte(reg&0XFF);   	//发送低8位地址
	CT_IIC_Wait_Ack();  
 	CT_IIC_Start();  	 	   
	CT_IIC_Send_Byte(GT_CMD_RD);   //发送读命令		   
	CT_IIC_Wait_Ack();	   
	for(i=0;i<len;i++)
	{	   
    	buf[i]=CT_IIC_Read_Byte(i==(len-1)?0:1); //发数据	  
	} 
    CT_IIC_Stop();//产生一个停止条件    
} 
//初始化GT1151触摸屏
//返回值:0,初始化成功;1,初始化失败 
u8 GT1151_Init(void)
{
	u8 temp[5];
	//u8 temp1[239]; 
	while(1){
		GPIO_InitTypeDef  GPIO_InitStructure;	
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);//使能PB端口时钟

		GPIO_InitStructure.GPIO_Pin =GPIO_Pin_0|GPIO_Pin_1;// PB0和PB1端口配置
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	//推挽输出
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
		GPIO_SetBits(GPIOB,GPIO_Pin_0);						//输出1
		GPIO_SetBits(GPIOB,GPIO_Pin_1);					//输出1


		CT_IIC_Init();      	//初始化电容屏的I2C总线  
		GT_RST=0;				//复位
		delay_ms(10);
		GT_RST=1;				//释放复位 
		delay_ms(10);
	
		GPIO_InitStructure.GPIO_Pin=GPIO_Pin_1;			//PC1端口配置
		GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPD;		//下拉输入
		GPIO_Init(GPIOB, &GPIO_InitStructure);			//PC1下拉输入
		GPIO_ResetBits(GPIOB,GPIO_Pin_1);				//下拉	
		delay_ms(100);
		GT1151_RD_Reg(GT_PID_REG,temp,4);//读取产品ID
		temp[4]=0;

		if(strcmp((char*)temp,"1151")==0){
			break;
		}
		delay_ms(1000);
	}
	//if(strcmp((char*)temp,"1151")==0)//ID==1151
	{
		temp[0]=0X2A;			
		GT1151_WR_Reg(GT_CTRL_REG,temp,1);//软复位GT1151
		GT1151_RD_Reg(GT_CFGS_REG,temp,1);//读取GT_CFGS_REG寄存器
		//if(temp[0]<0X60)//默认版本比较低,需要更新flash配置
		{
			GT1151_Send_Cfg(1);//更新并保存配置
		}
		delay_ms(10);
		temp[0]=0X00;	 
		GT1151_WR_Reg(GT_CTRL_REG,temp,1);//结束复位 
  		
			
		return 0;
	} 
	return 1;
}
const u16 GT1151_TPX_TBL[10]={GT_TP1_REG,GT_TP2_REG,GT_TP3_REG,GT_TP4_REG,GT_TP5_REG,GT_TP6_REG,GT_TP7_REG,GT_TP8_REG,GT_TP9_REG,GT_TP10_REG};
//扫描触摸屏(采用查询方式)
//mode:0,正常扫描.
//返回值:
 u8 GT1151_Scan(void)
{

	u8 buf[5];
	u8 i=0;
	u8 num=0;
	u8 temp;
	u8 ret = 0;
	static u8 t=0;//控制查询间隔,从而降低CPU占用率   
	t++;
	if((t%10)==0||t<10)//空闲时,每进入10次CTP_Scan函数才检测1次,从而节省CPU使用率
	{
		GT1151_RD_Reg(GT_GSTID_REG,&temp,1);//读取触摸点的状态 
		if(temp&0x80)
		{
			num=temp&0x0f;
			if(num<11)
			{
				for(i=0;i<num;i++)
				{
					GT1151_RD_Reg(GT1151_TPX_TBL[i],buf,5);	//读取XY坐标值
					tp_dev.tp_id[i]=buf[0];
					tp_dev.y[i]=((u16)buf[2]<<8)+buf[1];
					tp_dev.x[i]=((u16)buf[4]<<8)+buf[3];
					
				}	
			}
			t=0;
			temp=0;
			ret = GT1151_WR_Reg(GT_GSTID_REG,&temp,1);//清标志 	
			if(ret){/*iic通信失败*/
				GT1151_Init();
			}
		}
		
	}
		if(t>240)t=10;//重新从10开始计数
	return num;
	
	
}
/*
 u8 tp_id[5]={0};

 u8 GT1151_Status_Scan(void)
 {
	 u8 status=0;
	 u8 buf[4];
		u8 i=0;
		u8 num=0;
		u8 temp;
		static u8 t=0;//控制查询间隔,从而降低CPU占用率   
		t++;
		if((t%10)==0||t<10)//空闲时,每进入10次CTP_Scan函数才检测1次,从而节省CPU使用率
		{
			GT1151_RD_Reg(GT_GSTID_REG,&status,1);//读取触摸点的状态 
			num=status&0x0f;
			if((status&0X80)&&(status&0XF)&&((status&0XF)<6))
			{
				u8 buf[8]={0};
				
				for(i=0;i<num;i++)
				{
					GT1151_RD_Reg(0x814F,buf,5);
					tp_dev.tp_id[i]=buf[0];
					tp_dev.y[i]=((u16)buf[2]<<8)+buf[1];
					tp_dev.x[i]=800-(((u16)buf[4]<<8)+buf[3]);
				}
				temp=0;
				GT1151_WR_Reg(GT_GSTID_REG,&temp,1);//清标志				
				t=0;		//触发一次,则会最少连续监测10次,从而提高命中率
			}	
		}
	
		if((mode&0X8F)==0X80)//无触摸点按下
		{ 
			if(tp_dev.sta&TP_PRES_DOWN)	//之前是被按下的
			{
				tp_dev.sta&=~(1<<7);	//标记按键松开
			}else						//之前就没有被按下
			{ 
				tp_dev.x[0]=0xffff;
				tp_dev.y[0]=0xffff;
				tp_dev.sta&=0XE0;	//清除点有效标记	
			}	 
		} 	
		if(t>240)t=10;//重新从10开始计数
		return num;
 }



*/





















