/**********************************************************
* @ File name -> hw_iic.c
* @ Version   -> V1.0
* @ Date      -> 02-19-2014
* @ Brief     -> STM32硬件IIC驱动函数

 V1.
* @ Revise    -> 
**********************************************************/

#include "hw_iic.h"

/**********************************************************
               定义IIC操作过程中的错误标志
**********************************************************/

//bit0：发送起始位错误
//bit1：设备地址 + 写命令错误
//bit2：设备地址 + 读命令错误
//bit3：16位地址时发送高8位错误
//bit4：16位地址时发送低8位错误
//bit5：发送/接收数据错误
//bit6：应答错误

u8 IIC_RES_STA=0;

/**********************************************************
* 函数功能 ---> 检查总线状态
* 入口参数 ---> none
* 返回数值 ---> 0：总线空闲
*               1：总线忙
* 功能说明 ---> none
**********************************************************/
u8 IIC_Check_Busy(void)
{
	if(I2C1->SR2 & (1<<1))	return IIC_BUSYING;	//总线正在忙
	else return IIC_NoBUSY;	//总线空闲
}
/**********************************************************
* 函数功能 ---> IIC接口初始化
* 入口参数 ---> Slave_Add：从设备7位地址
* 返回数值 ---> none
* 功能说明 ---> none
**********************************************************/
void STM32hwIIC_Init(u8 Slave_Add)
{
	RCC->APB2ENR |= 1<<3;	//启动GPIOB时钟
	RCC->APB1ENR |= 1<<21;	//启动IIC1时钟

	GPIOB->CRL &= 0x00ffffff;	//清空PB.6和PB.7配置
	GPIOB->CRL |= 0xff000000;	//设置为复用开漏输出，最大速度为50MHz

	GPIOB->ODR |= 0x000000c0;	//PB.6、PB.7输出高电平

	//配置IIC功能
	I2C1->CR1 &= 0xfffe;	//失能IIC

	I2C1->CR1 &= 0xfbf5;	//清除ACK、SMBus类型、SMBus模式位
	I2C1->CR1 |= 0<<1;	//设置成IIC模式
	I2C1->CR1 |= 0<<3;	//主机模式
	I2C1->CR1 |= 1<<10;	//在接收到一个字节后返回一个应答(匹配的地址或数据)

	/******************************************************
	               下面的配置与SCL通讯频率有关
	   时钟来自APB1地址总线，模块频率取决与该总线分频系数
	******************************************************/

	I2C1->CR2 &= 0xffc0;	//清除IIC模块时钟频率
	I2C1->CR2 |= 0x0002;	//设置IIC模块时钟频率，2MHz【可以设定的范围为2MHz ~ 36MHz】
							//即FREQ[5:0] = 00 0010b ~ 10 0100之间	

	/* 以下两个寄存器CCR和TRISE要在PE = 0（关闭IIC模块）情况下才能设置 */

	I2C1->CR1 |= 0<<0;	//失能IIC模块

	//SCL最大上升时间
	//标准模式100KHz，上升为1000ns，下降为300ns
	//快速模式400KHz，上升为300ns，下降为300ns
	I2C1->TRISE |= 0x09;	//设置SCL最大上升为1ms

	//设置时钟控制寄存器
	//分频系数计算公式：CCP[11:0] = Tpclk1 / Thigh
	//Tpclk1由I2Cx->CR2寄存器取得的频率得来
	I2C1->CCR &= 0x7000;	//清除之前设置
	I2C1->CCR |= 0<<15;	//标准IIC模式
//	I2C1->CCR |= 0<<14;	//占空比为：Tlow / Thigh = 2
	I2C1->CCR |= 0x64;	//时钟控制分频系数（主模式）【定义SCL高电平和低电平维持时间都是5us】
	
	/******************************************************
	               结束SCL频率相关参数设定
	******************************************************/

	I2C1->CR1 |= 1<<10;	//使能IIC应答
	I2C1->CR1 |= 1<<0;	//使能IIC模块

	//自身地址寄存器设置
	I2C1->OAR1 &= 0x7c00;	//清除之前设置
	I2C1->OAR1 |= 0<<15;	//7位从地址
	I2C1->OAR1 |= Slave_Add;	//设置从设备7位地址
}
/**********************************************************
* 函数功能 ---> IIC写入数据
* 入口参数 ---> Slave_Add：从设备地址
*               Data_Add：从设备数据保存地址
*               *Bytebuff：要写入的字节数据缓存
*               len：写入数据长度
*               mode：写入芯片的数据存储地址位数。0:8位。1:16位
* 返回数值 ---> 0：成功
*               1：失败
*               其他值：指示细节错误
* 功能说明 ---> none
**********************************************************/
u8 STM32hw_Write_nByte(u8 Slave_Add, u16 Data_Add, u8 *Bytebuff, u8 len, u8 mode)
{
//	u8 retry=0x1f;	//超时计算
	u16 i;

	IIC_RES_STA = 0;	//清状态标志

	I2C1->CR1 |= 1<<10;	//允许应答
										
	/* 发送起始位 */
	I2C1->CR1 |= 1<<8;	//启动总线
	while(!((I2C1->SR1 & (1<<0))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (0<<1))))	{}
//	while(!((I2C1->SR1 & (1<<0))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (0<<1)))&&retry--)	{}	//等待起始位发送
//	if(retry == 0)	IIC_RES_STA |= IIC_START_ERROR;	//发送起始位出错
										 
	/* 发送设备地址 + 写命令 */
	I2C1->DR = Slave_Add;	//发送设备地址，写入数据
//	retry = 0x1f;
	while(!((I2C1->SR1 & (1<<1))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2))))	{}	//等待地址发送
//	while(!((I2C1->SR1 & (1<<1))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2)))&&retry--)	{}	//等待地址发送
//	if(retry == 0)	IIC_RES_STA |= IIC_SLAVE_ERROR;	//发送设备地址出错

//	retry = (u8)I2C1->SR2;	/* 读取SR2清除标志 */

//	/* 等待应答信号 */
//	retry = 0x1f;
//	while(!(I2C1->SR1 & (1<<10))&&retry--)	{}	//等待接收应答信号
//	if(retry == 0)	IIC_RES_STA |= IIC_ACK_ERROR;	//没有收到应答信号

//	if(!(I2C1->SR2 & (1<<0)))	return (IIC_RES_STA | IIC_NO_MASTER);	//不是主模式则退出
//	retry = (u8)I2C1->SR2;	/* 读取SR2清除标志 */
									   
	/* 发送数据地址的高8位 */
	if(mode)							 
	{
		I2C1->DR = Data_Add>>8;	//写数据地址高8位
//		retry = 0x1f;
		while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2))))	{}	//等待地址发送
//		while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2)))&&retry--)	{}	//等待地址发送
//		while(!(I2C1->SR1 & (1<<7))&&retry--)	{}	//等待写入完成
//		if(retry == 0)	IIC_RES_STA |= IIC_ADD_H_ERROR;	//发送高8位数据地址出错
	}
	/* 发送数据地址的低8位 */
	I2C1->DR = Data_Add%256;	//写数据地址低8位
//	retry = 0x1f;
	while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2))))	{}	//等待地址发送
//	while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2)))&&retry--)	{}	//等待地址发送
//	while(!(I2C1->SR1 & (1<<7))&&retry--)	{}	//等待写入完成
//	if(retry == 0)	IIC_RES_STA |= IIC_ADD_L_ERROR;	//发送低8位数据地址出错

//	retry = (u8)I2C1->SR2;	/* 读取SR2清除标志 */

	I2C1->CR1 |= 0<<9;	//产生停止条件

	/* 开始发送数据 */
	for(i = 0;i < len;i++)						
	{
		I2C1->DR = Bytebuff[i];	//发送数据
//		retry = 0x1f;
		while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2))))	{}	//等待数据发送
//		while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2)))&&retry--)	{}	//等待数据发送
//		while(!(I2C1->SR1 & (1<<7))&&retry--)	{}	//等待写入完成
//		if(retry == 0)	IIC_RES_STA |= IIC_DATA_ERROR;	//发送数据出错
	}
	/* 发送停止信号 */
	I2C1->CR1 |= 1<<9;	//产生停止条件
									
	return IIC_RES_STA;
}
/**********************************************************
* 函数功能 ---> IIC读取数据
* 入口参数 ---> Slave_Add：从设备地址
*               Data_Add：从设备数据保存地址
*               *Bytebuff：要写入的字节数据缓存
*               len：写入数据长度
*               mode：写入芯片的数据存储地址位数。0:8位。1:16位
* 返回数值 ---> 0：成功
*               1：失败
*               其他值：指示细节错误
* 功能说明 ---> none
**********************************************************/
u8 STM32hw_Read_nByte(u8 Slave_Add, u16 Data_Add, u8 *Bytebuff, u8 len, u8 mode)
{
//	u8 retry=0x1f;	//超时计算
	u16 i;

	IIC_RES_STA = 0;	//清状态标志

	/* 等待总线空闲 */
	while(IIC_Check_Busy() == IIC_BUSYING);

	I2C1->CR1 |= 1<<10;	//允许应答		  
										 
	/* 发送起始位 */
	I2C1->CR1 |= 1<<8;	//启动总线
  	while(!((I2C1->SR1 & (1<<0))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (0<<1))))	{}
//	while(!((I2C1->SR1 & (1<<0))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (0<<1)))&&retry--)	{}	//等待起始位发送
//	if(retry == 0)	IIC_RES_STA |= IIC_START_ERROR;	//发送起始位出错

	/* 发送设备地址 + 写命令 */
	I2C1->DR = Slave_Add;	//发送设备地址，写入数据
//	retry = 0x1f;
	while(!((I2C1->SR1 & (1<<1))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2))))	{}	//等待地址发送
//	while(!((I2C1->SR1 & (1<<1))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2)))&&retry--)	{}	//等待地址发送
//	if(retry == 0)	IIC_RES_STA |= IIC_SLAVE_ERROR;	//发送设备地址出错

//	/* 等待应答信号 */
//	retry = 0x1f;
//	while(!(I2C1->SR1 & (1<<10))&&retry--)	{}	//等待接收应答信号
//	if(retry == 0)	IIC_RES_STA |= IIC_ACK_ERROR;	//没有收到应答信号
//
////	if(!(I2C1->SR2 & (1<<0)))	return (IIC_RES_STA | IIC_NO_MASTER);	//不是主模式则退出
//	retry = (u8)I2C1->SR2;	/* 读取SR2清除标志 */

	I2C1->CR1 |= 1<<0;	//重新设置可以清除EV6

	/* 发送数据地址的高8位 */
	if(mode)
	{
		I2C1->DR = Data_Add>>8;	//写数据地址高8位
//		retry = 0x1f;
		while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2))))	{}	//等待地址发送
//		while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2)))&&retry--)	{}	//等待地址发送
//		while(!(I2C1->SR1 & (1<<7))&&retry--)	{}	//等待写入完成
//		if(retry == 0)	IIC_RES_STA |= IIC_ADD_H_ERROR;	//发送高8位数据地址出错
	}
	/* 发送数据地址的低8位 */
	I2C1->DR = Data_Add%256;	//写数据地址低8位
//	retry = 0x1f;
	while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2))))	{}	//等待地址发送
//	while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR1 & (1<<7))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))&&(I2C1->SR2 & (1<<2)))&&retry--)	{}	//等待地址发送
//	while(!(I2C1->SR1 & (1<<7))&&retry--)	{}	//等待写入完成
//	if(retry == 0)	IIC_RES_STA |= IIC_ADD_L_ERROR;	//发送低8位数据地址出错

	/* 重新启动总线 */
	I2C1->CR1 |= 1<<8;
//	retry = 0x1f;
	while(!((I2C1->SR1 & (1<<0))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (0<<1))))	{}
//	while(!((I2C1->SR1 & (1<<0))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (0<<1)))&&retry--)	{}	//等待起始位发送
//	while(!(I2C1->SR1 & (1<<0))&&retry--)	{}	//等待起始位发送
//	if(retry == 0)	IIC_RES_STA |= IIC_START_ERROR;	//重启总线发送起始位出错
											
	/* 发送设备地址 + 读取命令 */				
	I2C1->DR = Slave_Add | 0x01;	//发送设备地址，读取数据
//	retry = 0x1f;
	while(!((I2C1->SR1 & (1<<1))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))))	{}
//	while(!((I2C1->SR1 & (1<<1))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1)))&&retry--)	{}	//等待地址发送
//	while(!(I2C1->SR1 & (1<<1))&&retry--)	{}	//等待地址发送
//	if(retry == 0)	IIC_RES_STA |= IIC_READ_ERROR;	//发送读取命令出错

//	retry = (u8)I2C1->SR2;	/* 读取SR2清除标志 */
	

	/* 关闭应答 */
//	I2C1->CR1 |= 0<<10;
	/* 关闭停止位 */
	I2C1->CR1 |= 0<<9;

	/* 开始接收数据 */
	for(i = 0;i < len;i++)
	{						  
//		retry = 0x1f;
		while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1))))	{}
//		while(!((I2C1->SR1 & (1<<2))&&(I2C1->SR2 & (1<<0))&&(I2C1->SR2 & (1<<1)))&&retry--)	{}	//等待数据接收完成
//		if(retry == 0)	IIC_RES_STA |= IIC_DATA_ERROR;	//等待从设备发送数据失败

		Bytebuff[i] = I2C1->DR%256;	//读取数据

		if(i == (len - 1))	I2C1->CR1 |= 0<<10;	//发送非应答
		else	I2C1->CR1 |= 1<<10;	//发送应答
	}
	/* 发送停止信号 */
	I2C1->CR1 |= 1<<9;	//产生停止条件
	
	return IIC_RES_STA;
}

